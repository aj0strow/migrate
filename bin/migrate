#!/usr/bin/env node

// env

require('dotenv').load()

// dependencies

var minimist = require('minimist')
var co = require('co')
var util = require('util')
var chalk = require('chalk')
var pkg = require('../package.json')

// modules

var pg = require('../src/pg')
var parse = require('../src/parse')
var migrate = require('../src/migrate')
var lint = require('../src/lint')

// docs

var USAGE = `
 Usage:

  $ migrate [command] [arguments] [options]

 Commands:

  up   : migrate up database (optional prefix for target)
  down : migrate down database (optional prefix for target)
  redo : migrate down then back up to current migration
  lint : check migration files for database errors

 Arguments:

  An optional filename prefix. For migrating up, every filename <= prefix
  will be migrated. For down or redo, every filename >= prefix. 

 Options:

  -h, --help          output usage information
  --version           output the version number
  -n, --count <n>     number of migrations
  --all               migrate all files (default for up)
  --dir <path>        migrations directory (default pwd)
  --url/uri <url>     postgres url (default $DATABASE_URL)

 Examples:

  Run all pending migrations.

   $ migrate up --url postgres://localhost/dbname --dir db/migrations

  Undo the last three migrations.

   $ migrate down -n 3

  Redo the last migration and debug this command.

   $ DEBUG=migrate migrate redo
`

// options

var argv = minimist(process.argv.slice(2))
var args = argv._
var command = args.shift()

if (!command || argv.help || argv.h || command == 'help') {
  console.log(USAGE)
  process.exit(0)  
}

if (argv.version || argv.v || command == 'version') {
  console.log(pkg.version)
  process.exit(0)
}


var prefix = args.shift()
var count = argv.n || argv.count
if (prefix && count || prefix && argv.all || count && argv.all) {
  fail('file prefix, count option, all option are mutually exclusive')
}
var limit = prefix || (+count) || argv.all


var url = argv.url || argv.uri || process.env['DATABASE_URL']
if (!url) {
  fail('could not determine database url')
}
var db = pg.createClient(url)


var dir = argv.dir || process.cwd()


co(function * () {

  yield db.connect()
  yield db.init()
  var structs = yield parse.dir(dir)
  if (!structs.length) {
    fail('no sql files found in %s', dir)
  }

  switch (command) {
  case 'up':
  case 'down':
  case 'redo':
    return yield migrate[command](db, structs, limit)
  case 'lint':
    var errors = yield lint(db, structs)
    return errors.forEach(lintf)
  default:
    fail('no command %s', command)
  }

}).then(function () {
  process.exit(0)
}).catch(function (e) {
  fail('%s: %s', e.name, e.message)
})

// helpers

function fail () {
  var str = util.format.apply(util, arguments)
  process.stderr.write(chalk.red(str) + '\n')
  process.exit(1)
}

function lintf (error) {
  process.stderr.write('')
  console.log('error')
  process.stderr.write(chalk.red(''))
}
